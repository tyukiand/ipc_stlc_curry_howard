
// <BEGIN PREDEF>

// Types that represent disjunctions and conjunctions,
// essentially the same as `Either` and pair-types
sealed trait \/[A, B]
case class Inl[A, B](a: A) extends (A \/ B)
case class Inr[A, B](b: B) extends (A \/ B)

case class /\[A, B](a: A, b: B)

// Modus ponens is the implication elimination rule.
// modus ponens is just function application: A, A => B creates B
// The implication introduction is also not a method or axiom,
// but is rather modeled by Scala's anonymous function literals.

// Modus Ponens = function application
// Implication introduction = lambda abstraction

// however, for the purpose of theorem prover, it's actually 
// quite handy to have it as a rule that accepts two arguments
def impl_elim[A, B](f: A => B, x: A) : B = f(x)

// Disjunction introduction and elimination
def disj_intr_1[A, B](a: A) : A \/ B = Inl(a)
def disj_intr_2[A, B](b: B) : A \/ B = Inr(b)
def disj_elim[A, B, Z](az: A => Z, bz: B => Z, ab: A \/ B) :  Z = {
  ab match {
    case Inl(a) => az(a)
    case Inr(b) => bz(b)
  }
}

// Conjunction introduction and elimination
def conj_intr[A, B](a: A, b: B): A /\ B = /\(a, b)
def conj_elim_1[A, B](ab: A /\ B): A = ab.a
def conj_elim_2[A, B](ab: A /\ B): B = ab.b

// Nothing implies everything (explosion principle)
def explosion[X]: Nothing => X = { 
  unobtanium => throw new Exception("Gratz, you broke the world")
}

// Shorter notation for negation
type Neg[X] = (X => Nothing)
type Equiv[A, B] = (A => B) /\ (B => A)

// </END PREDEF>



/*
                                
----------------------(A)       ----------------------(A)
[(A /\ B)] |- (A /\ B)          [(A /\ B)] |- (A /\ B)
-------------------------(-C2)  -------------------------(-C1)
     [(A /\ B)] |- B                 [(A /\ B)] |- A     
--------------------------------------------------------------(+C)
                    [(A /\ B)] |- (B /\ A)                    
*/
def conj_commut[A,B](Cab:(A /\ B)):(B /\ A) = {
  val _g0:B = {
    val _g0:(A /\ B) = Cab
    conj_elim_2(_g0)
  }
  val _g1:A = {
    val _g0:(A /\ B) = Cab
    conj_elim_1(_g0)
  }
  conj_intr(_g0,_g1)
}


/*
                                                                        
------------------(A)               ------------------(A)               
[(A \/ B), A] |- A                  [(A \/ B), B] |- B                  
-------------------------(+D1)      -------------------------(+D2)      
[(A \/ B), A] |- (B \/ A)           [(A \/ B), B] |- (B \/ A)           
------------------------------(+I)  ------------------------------(+I)  ----------------------(A)
[(A \/ B)] |- (A => (B \/ A))       [(A \/ B)] |- (B => (B \/ A))       [(A \/ B)] |- (A \/ B)
-------------------------------------------------------------------------------------------------(-D)
                                     [(A \/ B)] |- (B \/ A)                                      
*/
def disj_commut[A,B](Dab:(A \/ B)):(B \/ A) = {
  val _g0:(A => (B \/ A)) = { a => {
      val _g0:A = a
      disj_intr_2(_g0)
    }
  }
  val _g1:(B => (B \/ A)) = { b => {
      val _g0:B = b
      disj_intr_1(_g0)
    }
  }
  val _g2:(A \/ B) = Dab
  disj_elim(_g0,_g1,_g2)
}


/*
                                                                                                     
                                              ------------------------------------(A)                
                                              [(A /\ (B /\ C))] |- (A /\ (B /\ C))                   
------------------------------------(A)       ---------------------------------------(-C2)           ------------------------------------(A)
[(A /\ (B /\ C))] |- (A /\ (B /\ C))               [(A /\ (B /\ C))] |- (B /\ C)                     [(A /\ (B /\ C))] |- (A /\ (B /\ C))
---------------------------------------(-C1)  --------------------------------------------(-C1)      ---------------------------------------(-C2)
        [(A /\ (B /\ C))] |- A                           [(A /\ (B /\ C))] |- B                           [(A /\ (B /\ C))] |- (B /\ C)     
-----------------------------------------------------------------------------------------------(+C)  --------------------------------------------(-C2)
                                 [(A /\ (B /\ C))] |- (A /\ B)                                                  [(A /\ (B /\ C))] |- C           
------------------------------------------------------------------------------------------------------------------------------------------------------(+C)
                                                         [(A /\ (B /\ C))] |- ((A /\ B) /\ C)                                                         
*/
def conj_assoc[A,B,C](CaCbc:(A /\ (B /\ C))):((A /\ B) /\ C) = {
  val _g0:(A /\ B) = {
    val _g0:A = {
      val _g0:(A /\ (B /\ C)) = CaCbc
      conj_elim_1(_g0)
    }
    val _g1:B = {
      val _g0:(B /\ C) = {
        val _g0:(A /\ (B /\ C)) = CaCbc
        conj_elim_2(_g0)
      }
      conj_elim_1(_g0)
    }
    conj_intr(_g0,_g1)
  }
  val _g1:C = {
    val _g0:(B /\ C) = {
      val _g0:(A /\ (B /\ C)) = CaCbc
      conj_elim_2(_g0)
    }
    conj_elim_2(_g0)
  }
  conj_intr(_g0,_g1)
}


/*
                                                                                                                                                                                                                              
                                                  -----------------------------------(A)                                                                                                                                      
                                                  [(A \/ (B \/ C)), (B \/ C), B] |- B                                                                                                                                         
                                                  ------------------------------------------(+D1)             -----------------------------------(A)                                                                          
                                                  [(A \/ (B \/ C)), (B \/ C), B] |- (A \/ B)                  [(A \/ (B \/ C)), (B \/ C), C] |- C                                                                             
-------------------------(A)                      -------------------------------------------------(+D2)      -------------------------------------------------(+D1)                                                          
[(A \/ (B \/ C)), A] |- A                         [(A \/ (B \/ C)), (B \/ C), B] |- ((A \/ B) \/ C)           [(A \/ (B \/ C)), (B \/ C), C] |- ((A \/ B) \/ C)                                                               
--------------------------------(+D2)             ------------------------------------------------------(+I)  ------------------------------------------------------(+I)  ---------------------------------------(A)          
[(A \/ (B \/ C)), A] |- (A \/ B)                  [(A \/ (B \/ C)), (B \/ C)] |- (B => ((A \/ B) \/ C))       [(A \/ (B \/ C)), (B \/ C)] |- (C => ((A \/ B) \/ C))       [(A \/ (B \/ C)), (B \/ C)] |- (B \/ C)             
---------------------------------------(+D2)      ------------------------------------------------------------------------------------------------------------------------------------------------------------------(-D)      
[(A \/ (B \/ C)), A] |- ((A \/ B) \/ C)                                                                     [(A \/ (B \/ C)), (B \/ C)] |- ((A \/ B) \/ C)                                                                    
--------------------------------------------(+I)  ----------------------------------------------------------------------------------------------------------------------------------------------------------------------(+I)  ------------------------------------(A)
[(A \/ (B \/ C))] |- (A => ((A \/ B) \/ C))                                                                 [(A \/ (B \/ C))] |- ((B \/ C) => ((A \/ B) \/ C))                                                                [(A \/ (B \/ C))] |- (A \/ (B \/ C))
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------(-D)
                                                                                                                [(A \/ (B \/ C))] |- ((A \/ B) \/ C)                                                                                                                 
*/
def disj_assoc[A,B,C](DaDbc:(A \/ (B \/ C))):((A \/ B) \/ C) = {
  val _g0:(A => ((A \/ B) \/ C)) = { a => {
      val _g0:(A \/ B) = {
        val _g0:A = a
        disj_intr_1(_g0)
      }
      disj_intr_1(_g0)
    }
  }
  val _g1:((B \/ C) => ((A \/ B) \/ C)) = { Cbc => {
      val _g0:(B => ((A \/ B) \/ C)) = { b => {
          val _g0:(A \/ B) = {
            val _g0:B = b
            disj_intr_2(_g0)
          }
          disj_intr_1(_g0)
        }
      }
      val _g1:(C => ((A \/ B) \/ C)) = { c => {
          val _g0:C = c
          disj_intr_2(_g0)
        }
      }
      val _g2:(B \/ C) = Cbc
      disj_elim(_g0,_g1,_g2)
    }
  }
  val _g2:(A \/ (B \/ C)) = DaDbc
  disj_elim(_g0,_g1,_g2)
}


/*

-----------(A)
[A, B] |- A
---------------(+I)
[A] |- (B => A)
*/
def k[A,B](a:A):(B => A) = { b => a
}


/*
                                                                                                                                                 
-------------------------------------------------(A)  -----------------------------------(A)      ------------------------------------------(A)  -----------------------------------(A)
[(A => (B => C)), (A => B), A] |- (A => (B => C))     [(A => (B => C)), (A => B), A] |- A         [(A => (B => C)), (A => B), A] |- (A => B)     [(A => (B => C)), (A => B), A] |- A
--------------------------------------------------------------------------------------------(-I)  -------------------------------------------------------------------------------------(-I)
                         [(A => (B => C)), (A => B), A] |- (B => C)                                                        [(A => (B => C)), (A => B), A] |- B                         
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------(-I)
                                                                            [(A => (B => C)), (A => B), A] |- C                                                                            
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------(+I)
                                                                            [(A => (B => C)), (A => B)] |- (A => C)                                                                            
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------(+I)
                                                                            [(A => (B => C))] |- ((A => B) => (A => C))                                                                            
*/
def s[A,B,C](IaIbc:(A => (B => C))):((A => B) => (A => C)) = { Iab => { a => {
      val _g0:(B => C) = {
        val _g0:(A => (B => C)) = IaIbc
        val _g1:A = a
        impl_elim(_g0,_g1)
      }
      val _g1:B = {
        val _g0:(A => B) = Iab
        val _g1:A = a
        impl_elim(_g0,_g1)
      }
      impl_elim(_g0,_g1)
    }
  }
}


/*
                                                                                                                     
-----------------------------------(A)  ----------------------------(A)      -----------------------------------(A)  ----------------------------(A)
[(A => B), (A => C), A] |- (A => B)     [(A => B), (A => C), A] |- A         [(A => B), (A => C), A] |- (A => C)     [(A => B), (A => C), A] |- A
-----------------------------------------------------------------------(-I)  -----------------------------------------------------------------------(-I)
                     [(A => B), (A => C), A] |- B                                                 [(A => B), (A => C), A] |- C                      
--------------------------------------------------------------------------------------------------------------------------------------------------------(+C)
                                                          [(A => B), (A => C), A] |- (B /\ C)                                                           
------------------------------------------------------------------------------------------------------------------------------------------------------------(+I)
                                                          [(A => B), (A => C)] |- (A => (B /\ C))                                                           
*/
def impl_distr_over_disj[A,B,C](Iab:(A => B),Iac:(A => C)):(A => (B /\ C)) = { a => {
    val _g0:B = {
      val _g0:(A => B) = Iab
      val _g1:A = a
      impl_elim(_g0,_g1)
    }
    val _g1:C = {
      val _g0:(A => C) = Iac
      val _g1:A = a
      impl_elim(_g0,_g1)
    }
    conj_intr(_g0,_g1)
  }
}


/*
                          
---------------------(A)  ----------------(A)
[Neg[A], A] |- Neg[A]     [Neg[A], A] |- A
---------------------------------------------(-I)
           [Neg[A], A] |- Nothing            
-------------------------------------------------(F!)
                [Neg[A], A] |- B                 
-----------------------------------------------------(+I)
                [Neg[A]] |- (A => B)                 
*/
def wrongPremiseImpliesAnything[A,B](IaF:Neg[A]):(A => B) = { a => {
    val _g0:Nothing = {
      val _g0:Neg[A] = IaF
      val _g1:A = a
      impl_elim(_g0,_g1)
    }
    explosion(_g0)
  }
}


/*
                          
---------------------(A)  ----------------(A)
[A, Neg[A]] |- Neg[A]     [A, Neg[A]] |- A
---------------------------------------------(-I)
           [A, Neg[A]] |- Nothing            
-------------------------------------------------(+I)
               [A] |- Neg[Neg[A]]                
*/
def doubleNeg[A](a:A):Neg[Neg[A]] = { IaF => {
    val _g0:Neg[A] = IaF
    val _g1:A = a
    impl_elim(_g0,_g1)
  }
}


/*
                                              
                                              --------------------------(A)
                                              [Neg[Neg[Neg[A]]], A] |- A
-----------------------------------------(A)  ------------------------------------(doubleNeg)
[Neg[Neg[Neg[A]]], A] |- Neg[Neg[Neg[A]]]     [Neg[Neg[Neg[A]]], A] |- Neg[Neg[A]]
---------------------------------------------------------------------------------------------(-I)
                              [Neg[Neg[Neg[A]]], A] |- Nothing                               
-------------------------------------------------------------------------------------------------(+I)
                                  [Neg[Neg[Neg[A]]]] |- Neg[A]                                   
*/
def tripleNeg[A](IIIaFFF:Neg[Neg[Neg[A]]]):Neg[A] = { a => {
    val _g0:Neg[Neg[Neg[A]]] = IIIaFFF
    val _g1:Neg[Neg[A]] = {
      val _g0:A = a
      doubleNeg(_g0)
    }
    impl_elim(_g0,_g1)
  }
}


/*
                                                                                
                                        -----------------------------------(A)  ----------------------------(A)
                                        [(A => B), (B => C), A] |- (A => B)     [(A => B), (B => C), A] |- A
-----------------------------------(A)  -----------------------------------------------------------------------(-I)
[(A => B), (B => C), A] |- (B => C)                          [(A => B), (B => C), A] |- B                      
-------------------------------------------------------------------------------------------------------------------(-I)
                                           [(A => B), (B => C), A] |- C                                            
-----------------------------------------------------------------------------------------------------------------------(+I)
                                           [(A => B), (B => C)] |- (A => C)                                            
*/
def hypotSyllog[A,B,C](Iab:(A => B),Ibc:(B => C)):(A => C) = { a => {
    val _g0:(B => C) = Ibc
    val _g1:B = {
      val _g0:(A => B) = Iab
      val _g1:A = a
      impl_elim(_g0,_g1)
    }
    impl_elim(_g0,_g1)
  }
}


/*
                                                                                  
------------------------------------(A)  ------------------------------------(A)  --------------------------------------(A)
[(A \/ B), Neg[A], Neg[B]] |- Neg[A]     [(A \/ B), Neg[A], Neg[B]] |- Neg[B]     [(A \/ B), Neg[A], Neg[B]] |- (A \/ B)
---------------------------------------------------------------------------------------------------------------------------(-D)
                                           [(A \/ B), Neg[A], Neg[B]] |- Nothing                                           
-------------------------------------------------------------------------------------------------------------------------------(+I)
                                               [(A \/ B), Neg[A]] |- Neg[Neg[B]]                                               
*/
def disjSyllog[A,B](Dab:(A \/ B),IaF:Neg[A]):Neg[Neg[B]] = { IbF => {
    val _g0:Neg[A] = IaF
    val _g1:Neg[B] = IbF
    val _g2:(A \/ B) = Dab
    disj_elim(_g0,_g1,_g2)
  }
}


/*
                              
-------------------------(A)  ------------------(A)
[(A => B), A] |- (A => B)     [(A => B), A] |- A
---------------------------------------------------(-I)
                [(A => B), A] |- B                 
*/
def modusPonens[A,B](Iab:(A => B),a:A):B = {
  val _g0:(A => B) = Iab
  val _g1:A = a
  impl_elim(_g0,_g1)
}


/*
                                   
------------------------------(A)  ----------------------------(A)
[(A => B), Neg[B]] |- (A => B)     [(A => B), Neg[B]] |- Neg[B]
------------------------------------------------------------------(hypotSyllog)
                   [(A => B), Neg[B]] |- Neg[A]                   
*/
def modusTollens[A,B](Iab:(A => B),IbF:Neg[B]):Neg[A] = {
  val _g0:(A => B) = Iab
  val _g1:Neg[B] = IbF
  hypotSyllog(_g0,_g1)
}


/*
                                                                                                                                                                                                                                        
                                               --------------------------------------(A)                                                                           --------------------------------------(A)                            
                                               [(A \/ B), (A => C), (B => D), C] |- C                                                                              [(A \/ B), (A => C), (B => D), D] |- D                               
                                               ---------------------------------------------(+D2)                                                                  ---------------------------------------------(+D1)                   
                                               [(A \/ B), (A => C), (B => D), C] |- (C \/ D)                                                                       [(A \/ B), (A => C), (B => D), D] |- (C \/ D)                        
------------------------------------------(A)  --------------------------------------------------(+I)               ------------------------------------------(A)  --------------------------------------------------(+I)               
[(A \/ B), (A => C), (B => D)] |- (A => C)     [(A \/ B), (A => C), (B => D)] |- (C => (C \/ D))                    [(A \/ B), (A => C), (B => D)] |- (B => D)     [(A \/ B), (A => C), (B => D)] |- (D => (C \/ D))                    
-----------------------------------------------------------------------------------------------------(hypotSyllog)  -----------------------------------------------------------------------------------------------------(hypotSyllog)  ------------------------------------------(A)
                          [(A \/ B), (A => C), (B => D)] |- (A => (C \/ D))                                                                   [(A \/ B), (A => C), (B => D)] |- (B => (C \/ D))                                         [(A \/ B), (A => C), (B => D)] |- (A \/ B)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------(-D)
                                                                                                                     [(A \/ B), (A => C), (B => D)] |- (C \/ D)                                                                                                                      
*/
def constructiveDilemma[A,B,C,D](Dab:(A \/ B),Iac:(A => C),Ibd:(B => D)):(C \/ D) = {
  val _g0:(A => (C \/ D)) = {
    val _g0:(A => C) = Iac
    val _g1:(C => (C \/ D)) = { c => {
        val _g0:C = c
        disj_intr_1(_g0)
      }
    }
    hypotSyllog(_g0,_g1)
  }
  val _g1:(B => (C \/ D)) = {
    val _g0:(B => D) = Ibd
    val _g1:(D => (C \/ D)) = { d => {
        val _g0:D = d
        disj_intr_2(_g0)
      }
    }
    hypotSyllog(_g0,_g1)
  }
  val _g2:(A \/ B) = Dab
  disj_elim(_g0,_g1,_g2)
}


/*
                                                                                                                                                                                                                                                                                                                                                   
                                                                   ------------------------------------------------------------(A)  -----------------------------------------------------(A)               ------------------------------------------------------------(A)  -----------------------------------------------------(A)               
                                                                   [Neg[(C \/ D)], (A => C), (B => D), A, (A \/ B)] |- (A => C)     [Neg[(C \/ D)], (A => C), (B => D), A, (A \/ B)] |- A                  [Neg[(C \/ D)], (A => C), (B => D), B, (A \/ B)] |- (B => D)     [Neg[(C \/ D)], (A => C), (B => D), B, (A \/ B)] |- B                  
                                                                   -------------------------------------------------------------------------------------------------------------------------(-I)           -------------------------------------------------------------------------------------------------------------------------(-I)           
                                                                                                     [Neg[(C \/ D)], (A => C), (B => D), A, (A \/ B)] |- C                                                                                   [Neg[(C \/ D)], (A => C), (B => D), B, (A \/ B)] |- D                                                 
                                                                   -----------------------------------------------------------------------------------------------------------------------------(+D2)      -----------------------------------------------------------------------------------------------------------------------------(+D1)      
                                                                                                   [Neg[(C \/ D)], (A => C), (B => D), A, (A \/ B)] |- (C \/ D)                                                                            [Neg[(C \/ D)], (A => C), (B => D), B, (A \/ B)] |- (C \/ D)                                            
                                                                   ----------------------------------------------------------------------------------------------------------------------------------(+I)  ----------------------------------------------------------------------------------------------------------------------------------(+I)  ---------------------------------------------------------(A)
                                                                                                    [(A => C), (B => D), Neg[(C \/ D)], (A \/ B)] |- (A => (C \/ D))                                                                        [(A => C), (B => D), Neg[(C \/ D)], (A \/ B)] |- (B => (C \/ D))                                       [(A => C), (B => D), Neg[(C \/ D)], (A \/ B)] |- (A \/ B)
--------------------------------------------------------------(A)  --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------(-D)
[(A => C), (B => D), Neg[(C \/ D)], (A \/ B)] |- Neg[(C \/ D)]                                                                                                                                              [(A => C), (B => D), Neg[(C \/ D)], (A \/ B)] |- (C \/ D)                                                                                                                                          
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------(-I)
                                                                                                                                                                             [(A => C), (B => D), Neg[(C \/ D)], (A \/ B)] |- Nothing                                                                                                                                                                              
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------(+I)
                                                                                                                                                                                 [(A => C), (B => D), Neg[(C \/ D)]] |- Neg[(A \/ B)]                                                                                                                                                                                  
*/
def destructiveDilemma[A,B,C,D](Iac:(A => C),Ibd:(B => D),IDcdF:Neg[(C \/ D)]):Neg[(A \/ B)] = { Dab => {
    val _g0:Neg[(C \/ D)] = IDcdF
    val _g1:(C \/ D) = {
      val _g0:(A => (C \/ D)) = { a => {
          val _g0:C = {
            val _g0:(A => C) = Iac
            val _g1:A = a
            impl_elim(_g0,_g1)
          }
          disj_intr_1(_g0)
        }
      }
      val _g1:(B => (C \/ D)) = { b => {
          val _g0:D = {
            val _g0:(B => D) = Ibd
            val _g1:B = b
            impl_elim(_g0,_g1)
          }
          disj_intr_2(_g0)
        }
      }
      val _g2:(A \/ B) = Dab
      disj_elim(_g0,_g1,_g2)
    }
    impl_elim(_g0,_g1)
  }
}


/*
                                                                                  
------------------------------------(A)  ------------------------------------(A)  --------------------------------------(A)
[Neg[A], Neg[B], (A \/ B)] |- Neg[A]     [Neg[A], Neg[B], (A \/ B)] |- Neg[B]     [Neg[A], Neg[B], (A \/ B)] |- (A \/ B)
---------------------------------------------------------------------------------------------------------------------------(-D)
                                           [Neg[A], Neg[B], (A \/ B)] |- Nothing                                           
-------------------------------------------------------------------------------------------------------------------------------(+I)
                                               [Neg[A], Neg[B]] |- Neg[(A \/ B)]                                               
*/
def deMorgan[A,B](IaF:Neg[A],IbF:Neg[B]):Neg[(A \/ B)] = { Cab => {
    val _g0:Neg[A] = IaF
    val _g1:Neg[B] = IbF
    val _g2:(A \/ B) = Cab
    disj_elim(_g0,_g1,_g2)
  }
}


/*
                                                                                                                                    
-----------------------(A)                                                                 -----------------------(A)               
[Neg[(A \/ B)], A] |- A                                                                    [Neg[(A \/ B)], B] |- B                  
------------------------------(+D2)                                                        ------------------------------(+D1)      
[Neg[(A \/ B)], A] |- (A \/ B)                                                             [Neg[(A \/ B)], B] |- (A \/ B)           
-----------------------------------(+I)  --------------------------------(A)               -----------------------------------(+I)  --------------------------------(A)
[Neg[(A \/ B)]] |- (A => (A \/ B))       [Neg[(A \/ B)]] |- Neg[(A \/ B)]                  [Neg[(A \/ B)]] |- (B => (A \/ B))       [Neg[(A \/ B)]] |- Neg[(A \/ B)]
----------------------------------------------------------------------------(hypotSyllog)  ----------------------------------------------------------------------------(hypotSyllog)
                         [Neg[(A \/ B)]] |- Neg[A]                                                                  [Neg[(A \/ B)]] |- Neg[B]                          
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------(+C)
                                                                       [Neg[(A \/ B)]] |- (Neg[A] /\ Neg[B])                                                                        
*/
def deMorgan_2[A,B](IDabF:Neg[(A \/ B)]):(Neg[A] /\ Neg[B]) = {
  val _g0:Neg[A] = {
    val _g0:(A => (A \/ B)) = { a => {
        val _g0:A = a
        disj_intr_1(_g0)
      }
    }
    val _g1:Neg[(A \/ B)] = IDabF
    hypotSyllog(_g0,_g1)
  }
  val _g1:Neg[B] = {
    val _g0:(B => (A \/ B)) = { b => {
        val _g0:B = b
        disj_intr_2(_g0)
      }
    }
    val _g1:Neg[(A \/ B)] = IDabF
    hypotSyllog(_g0,_g1)
  }
  conj_intr(_g0,_g1)
}
